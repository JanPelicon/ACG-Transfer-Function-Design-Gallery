{"TransferFunction":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = aPosition * 0.5 + 0.5;\n    gl_Position = vec4(aPosition, 0, 1);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform vec2 uPosition;\nuniform vec2 uSize;\nuniform vec4 uColor;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    float r = length((uPosition - vPosition) / uSize);\n    oColor = uColor * exp(-r * r);\n}\n"},"average":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vFragmentPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTextureAccumulator;\nuniform mediump sampler2D uTextureNew;\nuniform float uInvn; // inverse number of samples\n\nin vec2 vFragmentPosition;\nout vec4 color;\n\nvoid main() {\n    vec4 a = texture(uTextureAccumulator, vFragmentPosition);\n    vec4 b = texture(uTextureNew, vFragmentPosition);\n    color = a + (b - a) * uInvn;\n}\n"},"quad":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vFragmentPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vFragmentPosition = (aPosition + vec2(1.0, 1.0)) * 0.5;\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\n\nin vec2 vFragmentPosition;\nout vec4 color;\n\nvoid main() {\n    color = texture(uTexture, vFragmentPosition);\n}\n"},"renderers":{"DOS":{"integrate":{"vertex":"#version 300 es\n\nuniform mat4 uMvpInverseMatrix;\nuniform float uDepth;\n\nlayout (location = 0) in vec2 aPosition;\n\nout vec2 vPosition2D;\nout vec3 vPosition3D;\n\nvoid main() {\n    vec4 dirty = uMvpInverseMatrix * vec4(aPosition, uDepth, 1);\n    vPosition3D = dirty.xyz / dirty.w;\n    vPosition2D = aPosition * 0.5 + 0.5;\n    gl_Position = vec4(aPosition, 0, 1);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler3D uVolume;\nuniform mediump sampler2D uTransferFunction;\n\nuniform mediump sampler2D uColor;\nuniform mediump sampler2D uOcclusion;\nuniform mediump sampler2D uOcclusionSamples;\n\nuniform float uExtinction;\nuniform float uSliceDistance;\nuniform vec2 uOcclusionScale;\nuniform uint uOcclusionSamplesCount;\n\nin vec2 vPosition2D;\nin vec3 vPosition3D;\n\nlayout (location = 0) out vec4 oColor;\nlayout (location = 1) out float oOcclusion;\n\nvec4 sampleVolumeColor(vec3 position) {\n    vec2 volumeSample = texture(uVolume, position).rg;\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\n    return transferSample;\n}\n\nfloat calculateOcclusion(float extinction) {\n    float occlusion = 0.0;\n    for (uint i = 0u; i < uOcclusionSamplesCount; i++) {\n        vec2 occlusionSampleOffset = texelFetch(uOcclusionSamples, ivec2(i, 0), 0).rg;\n        vec2 occlusionSamplePosition = vPosition2D + occlusionSampleOffset * uOcclusionScale;\n        occlusion += texture(uOcclusion, occlusionSamplePosition).r;\n    }\n    return (occlusion / float(uOcclusionSamplesCount)) * exp(-extinction * uSliceDistance);\n}\n\nvoid main() {\n    vec4 prevColor = texture(uColor, vPosition2D);\n    float prevOcclusion = texture(uOcclusion, vPosition2D).r;\n\n    if (any(greaterThan(vPosition3D, vec3(1))) || any(lessThan(vPosition3D, vec3(0)))) {\n        oColor = prevColor;\n        oOcclusion = prevOcclusion;\n    } else {\n        vec4 transferSample = sampleVolumeColor(vPosition3D);\n        float extinction = transferSample.a * uExtinction;\n        float alpha = 1.0 - exp(-extinction * uSliceDistance);\n        vec3 color = transferSample.rgb * prevOcclusion * alpha;\n        oColor = prevColor + vec4(color * (1.0 - prevColor.a), alpha);\n        oColor.a = min(oColor.a, 1.0);\n        oOcclusion = calculateOcclusion(extinction);\n    }\n}\n"},"render":{"vertex":"#version 300 es\n\nlayout (location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = aPosition * 0.5 + 0.5;\n    gl_Position = vec4(aPosition, 0, 1);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    vec4 color = texture(uAccumulator, vPosition);\n    oColor = mix(vec4(1), vec4(color.rgb, 1), color.a);\n}\n"},"reset":{"vertex":"#version 300 es\n\nlayout (location = 0) in vec2 aPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nlayout (location = 0) out vec4 oColor;\nlayout (location = 1) out float oOcclusion;\n\nvoid main() {\n    oColor = vec4(0);\n    oOcclusion = 1.0;\n}\n"}},"EAM":{"generate":{"vertex":"#version 300 es\n\nuniform mat4 uMvpInverseMatrix;\n\nlayout(location = 0) in vec2 aPosition;\nout vec3 vRayFrom;\nout vec3 vRayTo;\n\n// #link /glsl/mixins/unproject.glsl\n@unproject\n\nvoid main() {\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\n    gl_Position = vec4(aPosition, 0, 1);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler3D uVolume;\nuniform mediump sampler2D uTransferFunction;\nuniform float uStepSize;\nuniform float uOffset;\nuniform float uExtinction;\n\nin vec3 vRayFrom;\nin vec3 vRayTo;\nout vec4 oColor;\n\n// #link /glsl/mixins/intersectCube.glsl\n@intersectCube\n\nvec4 sampleVolumeColor(vec3 position) {\n    vec2 volumeSample = texture(uVolume, position).rg;\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\n    return transferSample;\n}\n\nvoid main() {\n    vec3 rayDirection = vRayTo - vRayFrom;\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\n    if (tbounds.x >= tbounds.y) {\n        oColor = vec4(0, 0, 0, 1);\n    } else {\n        vec3 from = mix(vRayFrom, vRayTo, tbounds.x);\n        vec3 to = mix(vRayFrom, vRayTo, tbounds.y);\n        float rayStepLength = distance(from, to) * uStepSize;\n\n        float t = 0.0;\n        vec4 accumulator = vec4(0);\n\n        while (t < 1.0 && accumulator.a < 0.99) {\n            vec3 position = mix(from, to, t);\n            vec4 colorSample = sampleVolumeColor(position);\n            colorSample.a *= rayStepLength * uExtinction;\n            colorSample.rgb *= colorSample.a;\n            accumulator += (1.0 - accumulator.a) * colorSample;\n            t += uStepSize;\n        }\n\n        if (accumulator.a > 1.0) {\n            accumulator.rgb /= accumulator.a;\n        }\n\n        oColor = vec4(accumulator.rgb, 1);\n    }\n}\n"},"integrate":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = aPosition * 0.5 + 0.5;\n    gl_Position = vec4(aPosition, 0, 1);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\nuniform mediump sampler2D uFrame;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    oColor = texture(uFrame, vPosition);\n}\n"},"render":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = aPosition * 0.5 + 0.5;\n    gl_Position = vec4(aPosition, 0, 1);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    oColor = texture(uAccumulator, vPosition);\n}\n"},"reset":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nout vec4 oColor;\n\nvoid main() {\n    oColor = vec4(0, 0, 0, 1);\n}\n"}},"ISO":{"generate":{"vertex":"#version 300 es\nprecision mediump float;\n\nuniform mat4 uMvpInverseMatrix;\n\nlayout (location = 0) in vec2 aPosition;\n\nout vec2 vPosition;\nout vec3 vRayFrom;\nout vec3 vRayTo;\n\n// #link /glsl/mixins/unproject\n@unproject\n\nvoid main() {\n    vPosition = aPosition * 0.5 + 0.5;\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uClosest;\nuniform mediump sampler3D uVolume;\nuniform float uStepSize;\nuniform float uOffset;\nuniform float uIsovalue;\n\nin vec2 vPosition;\nin vec3 vRayFrom;\nin vec3 vRayTo;\n\nout vec4 oClosest;\n\n// #link /glsl/mixins/intersectCube\n@intersectCube\n\nvoid main() {\n    vec3 rayDirection = vRayTo - vRayFrom;\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\n    if (tbounds.x >= tbounds.y) {\n        oClosest = vec4(-1);\n    } else {\n        vec4 from = vec4(mix(vRayFrom, vRayTo, tbounds.x), tbounds.x);\n        vec4 to = vec4(mix(vRayFrom, vRayTo, tbounds.y), tbounds.y);\n\n        float closest = texture(uClosest, vPosition).w;\n        if (closest > 0.0) {\n            tbounds.y = closest;\n        }\n\n        float t = 0.0;\n        float offset = uOffset;\n        vec3 pos;\n        float value;\n        bool found = false;\n        do {\n            pos = mix(from.xyz, to.xyz, offset);\n            value = texture(uVolume, pos).r;\n            if (value >= uIsovalue) {\n                tbounds.y = mix(from.w, to.w, offset);\n                to = vec4(mix(vRayFrom, vRayTo, tbounds.y), tbounds.y);\n                found = true;\n            }\n            t += uStepSize;\n            offset = mod(offset + uStepSize + uOffset, 1.0);\n        } while (t < 1.0);\n\n        if (found) {\n            oClosest = to;\n        } else {\n            oClosest = vec4(-1);\n        }\n    }\n}\n"},"integrate":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout (location = 0) in vec2 aPosition;\n\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\nuniform mediump sampler2D uFrame;\n\nin vec2 vPosition;\n\nout vec4 oClosest;\n\nvoid main() {\n    vec4 frame = texture(uFrame, vPosition);\n    vec4 acc = texture(uAccumulator, vPosition);\n    if (frame.w > 0.0 && acc.w > 0.0) {\n        oClosest = frame.w < acc.w ? frame : acc;\n    } else if (frame.w > 0.0) {\n        oClosest = frame;\n    } else {\n        oClosest = acc;\n    }\n}\n"},"render":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout (location = 0) in vec2 aPosition;\n\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uClosest;\nuniform mediump sampler3D uVolume;\nuniform vec3 uLight;\nuniform vec3 uDiffuse;\n\nin vec2 vPosition;\n\nout vec4 oColor;\n\nvec3 gradient(vec3 pos, float h) {\n    vec3 positive = vec3(\n        texture(uVolume, pos + vec3( h, 0.0, 0.0)).r,\n        texture(uVolume, pos + vec3(0.0,  h, 0.0)).r,\n        texture(uVolume, pos + vec3(0.0, 0.0,  h)).r\n    );\n    vec3 negative = vec3(\n        texture(uVolume, pos + vec3(-h, 0.0, 0.0)).r,\n        texture(uVolume, pos + vec3(0.0, -h, 0.0)).r,\n        texture(uVolume, pos + vec3(0.0, 0.0, -h)).r\n    );\n    return normalize(positive - negative);\n}\n\nvoid main() {\n    vec4 closest = texture(uClosest, vPosition);\n\n    if (closest.w > 0.0) {\n        vec3 normal = normalize(gradient(closest.xyz, 0.005));\n        vec3 light = normalize(uLight);\n        float lambert = max(dot(normal, light), 0.0);\n        oColor = vec4(uDiffuse * lambert, 1.0);\n    } else {\n        oColor = vec4(1.0);\n    }\n}\n"},"reset":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout (location = 0) in vec2 aPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nout vec4 oClosest;\n\nvoid main() {\n    oClosest = vec4(-1);\n}\n"}},"MCM":{"integrate":{"vertex":"#version 300 es\n\nlayout (location = 0) in vec2 aPosition;\n\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = aPosition;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\n#define M_INVPI 0.31830988618\n#define M_2PI 6.28318530718\n#define EPS 1e-5\n\n// #link /glsl/mixins/Photon\n@Photon\n// #link /glsl/mixins/rand\n@rand\n// #link /glsl/mixins/unprojectRand\n@unprojectRand\n// #link /glsl/mixins/intersectCube\n@intersectCube\n\nuniform mediump sampler2D uPosition;\nuniform mediump sampler2D uDirection;\nuniform mediump sampler2D uTransmittance;\nuniform mediump sampler2D uRadiance;\n\nuniform mediump sampler3D uVolume;\nuniform mediump sampler2D uTransferFunction;\nuniform mediump sampler2D uEnvironment;\n\nuniform mat4 uMvpInverseMatrix;\nuniform vec2 uInverseResolution;\nuniform float uRandSeed;\nuniform float uBlur;\n\nuniform float uAbsorptionCoefficient;\nuniform float uScatteringCoefficient;\nuniform float uScatteringBias;\nuniform float uMajorant;\nuniform uint uMaxBounces;\nuniform uint uSteps;\n\nin vec2 vPosition;\n\nlayout (location = 0) out vec4 oPosition;\nlayout (location = 1) out vec4 oDirection;\nlayout (location = 2) out vec4 oTransmittance;\nlayout (location = 3) out vec4 oRadiance;\n\nvoid resetPhoton(inout vec2 randState, inout Photon photon) {\n    vec3 from, to;\n    unprojectRand(randState, vPosition, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\n    photon.direction = normalize(to - from);\n    photon.bounces = 0u;\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\n    photon.position = from + tbounds.x * photon.direction;\n    photon.transmittance = vec3(1);\n}\n\nvec4 sampleEnvironmentMap(vec3 d) {\n    vec2 texCoord = vec2(atan(d.x, -d.z), asin(-d.y) * 2.0) * M_INVPI * 0.5 + 0.5;\n    return texture(uEnvironment, texCoord);\n}\n\nvec4 sampleVolumeColor(vec3 position) {\n    vec2 volumeSample = texture(uVolume, position).rg;\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\n    return transferSample;\n}\n\nvec3 randomDirection(vec2 U) {\n    float phi = U.x * M_2PI;\n    float z = U.y * 2.0 - 1.0;\n    float k = sqrt(1.0 - z * z);\n    return vec3(k * cos(phi), k * sin(phi), z);\n}\n\nfloat sampleHenyeyGreensteinAngleCosine(float g, float U) {\n    float g2 = g * g;\n    float c = (1.0 - g2) / (1.0 - g + 2.0 * g * U);\n    return (1.0 + g2 - c * c) / (2.0 * g);\n}\n\nvec3 sampleHenyeyGreenstein(float g, vec2 U, vec3 direction) {\n    // generate random direction and adjust it so that the angle is HG-sampled\n    vec3 u = randomDirection(U);\n    if (abs(g) < EPS) {\n        return u;\n    }\n    float hgcos = sampleHenyeyGreensteinAngleCosine(g, fract(sin(U.x * 12345.6789) + 0.816723));\n    float lambda = hgcos - dot(direction, u);\n    return normalize(u + lambda * direction);\n}\n\nvoid main() {\n    Photon photon;\n    vec2 mappedPosition = vPosition * 0.5 + 0.5;\n    photon.position = texture(uPosition, mappedPosition).xyz;\n    vec4 directionAndBounces = texture(uDirection, mappedPosition);\n    photon.direction = directionAndBounces.xyz;\n    photon.bounces = uint(directionAndBounces.w + 0.5);\n    photon.transmittance = texture(uTransmittance, mappedPosition).rgb;\n    vec4 radianceAndSamples = texture(uRadiance, mappedPosition);\n    photon.radiance = radianceAndSamples.rgb;\n    photon.samples = uint(radianceAndSamples.w + 0.5);\n\n    vec2 r = rand(vPosition * uRandSeed);\n    for (uint i = 0u; i < uSteps; i++) {\n        r = rand(r);\n        float t = -log(r.x) / uMajorant;\n        photon.position += t * photon.direction;\n\n        vec4 volumeSample = sampleVolumeColor(photon.position);\n        float muAbsorption = volumeSample.a * uAbsorptionCoefficient;\n        float muScattering = volumeSample.a * uScatteringCoefficient;\n        float muNull = uMajorant - muAbsorption - muScattering;\n        float muMajorant = muAbsorption + muScattering + abs(muNull);\n        float PNull = abs(muNull) / muMajorant;\n        float PAbsorption = muAbsorption / muMajorant;\n        float PScattering = muScattering / muMajorant;\n\n        if (any(greaterThan(photon.position, vec3(1))) || any(lessThan(photon.position, vec3(0)))) {\n            // out of bounds\n            vec4 envSample = sampleEnvironmentMap(photon.direction);\n            vec3 radiance = photon.transmittance * envSample.rgb;\n            photon.samples++;\n            photon.radiance += (radiance - photon.radiance) / float(photon.samples);\n            resetPhoton(r, photon);\n        } else if (photon.bounces >= uMaxBounces) {\n            // max bounces achieved -> only estimate transmittance\n            float weightAS = (muAbsorption + muScattering) / uMajorant;\n            photon.transmittance *= 1.0 - weightAS;\n        } else if (r.y < PAbsorption) {\n            // absorption\n            float weightA = muAbsorption / (uMajorant * PAbsorption);\n            photon.transmittance *= 1.0 - weightA;\n        } else if (r.y < PAbsorption + PScattering) {\n            // scattering\n            r = rand(r);\n            float weightS = muScattering / (uMajorant * PScattering);\n            photon.transmittance *= volumeSample.rgb * weightS;\n            photon.direction = sampleHenyeyGreenstein(uScatteringBias, r, photon.direction);\n            photon.bounces++;\n        } else {\n            // null collision\n            float weightN = muNull / (uMajorant * PNull);\n            photon.transmittance *= weightN;\n        }\n    }\n\n    oPosition = vec4(photon.position, 0);\n    oDirection = vec4(photon.direction, float(photon.bounces));\n    oTransmittance = vec4(photon.transmittance, 0);\n    oRadiance = vec4(photon.radiance, float(photon.samples));\n}\n"},"render":{"vertex":"#version 300 es\n\nlayout (location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uColor;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    oColor = vec4(texture(uColor, vPosition).rgb, 1);\n}\n"},"reset":{"vertex":"#version 300 es\n\nlayout (location = 0) in vec2 aPosition;\n\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = aPosition;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\n// #link /glsl/mixins/Photon\n@Photon\n// #link /glsl/mixins/rand\n@rand\n// #link /glsl/mixins/unprojectRand\n@unprojectRand\n// #link /glsl/mixins/intersectCube\n@intersectCube\n\nuniform mat4 uMvpInverseMatrix;\nuniform vec2 uInverseResolution;\nuniform float uRandSeed;\nuniform float uBlur;\n\nin vec2 vPosition;\n\nlayout (location = 0) out vec4 oPosition;\nlayout (location = 1) out vec4 oDirection;\nlayout (location = 2) out vec4 oTransmittance;\nlayout (location = 3) out vec4 oRadiance;\n\nvoid main() {\n    Photon photon;\n    vec3 from, to;\n    vec2 randState = rand(vPosition * uRandSeed);\n    unprojectRand(randState, vPosition, uMvpInverseMatrix, uInverseResolution, uBlur, from, to);\n    photon.direction = normalize(to - from);\n    vec2 tbounds = max(intersectCube(from, photon.direction), 0.0);\n    photon.position = from + tbounds.x * photon.direction;\n    photon.transmittance = vec3(1);\n    photon.radiance = vec3(1);\n    photon.bounces = 0u;\n    photon.samples = 0u;\n    oPosition = vec4(photon.position, 0);\n    oDirection = vec4(photon.direction, float(photon.bounces));\n    oTransmittance = vec4(photon.transmittance, 0);\n    oRadiance = vec4(photon.radiance, float(photon.samples));\n}\n"}},"MCS":{"generate":{"vertex":"#version 300 es\nprecision mediump float;\n\nuniform mat4 uMvpInverseMatrix;\n\nlayout(location = 0) in vec2 aPosition;\nout vec3 vRayFrom;\nout vec3 vRayTo;\nout vec2 vPosition;\n\n// #link /glsl/mixins/unproject\n@unproject\n\nvoid main() {\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\n#define M_INVPI 0.31830988618\n\nuniform mediump sampler3D uVolume;\nuniform mediump sampler2D uTransferFunction;\nuniform mediump sampler2D uEnvironment;\nuniform float uOffset;\nuniform float uSigmaMax;\nuniform float uAlphaCorrection;\nuniform vec3 uScatteringDirection;\n\nin vec3 vRayFrom;\nin vec3 vRayTo;\nin vec2 vPosition;\nout vec4 oColor;\n\n// #link /glsl/mixins/intersectCube\n@intersectCube\n\nvec2 rand(vec2 p) {\n    const mat2 M = mat2(\n        23.14069263277926, 2.665144142690225,\n        12.98987893203892, 78.23376739376591);\n    const vec2 D = vec2(\n        12345.6789,\n        43758.5453);\n    vec2 dotted = M * p;\n    vec2 mapped = vec2(cos(dotted.x), sin(dotted.y));\n    return fract(mapped * D);\n}\n\nvec4 sampleEnvironmentMap(vec3 d) {\n    vec2 texCoord = vec2(atan(d.x, -d.z), asin(-d.y) * 2.0) * M_INVPI * 0.5 + 0.5;\n    return texture(uEnvironment, texCoord);\n}\n\nvec4 sampleVolumeColor(vec3 position) {\n    vec2 volumeSample = texture(uVolume, position).rg;\n    vec4 transferSample = texture(uTransferFunction, volumeSample);\n    return transferSample;\n}\n\nfloat sampleDistance(vec3 from, vec3 to, inout vec2 seed) {\n    float maxDistance = distance(from, to);\n    float dist = 0.0;\n    float invSigmaMax = 1.0 / uSigmaMax;\n    float invMaxDistance = 1.0 / maxDistance;\n\n    do {\n        seed = rand(seed);\n        dist -= log(1.0 - seed.x) * invSigmaMax;\n        if (dist > maxDistance) {\n            break;\n        }\n        vec3 samplingPosition = mix(from, to, dist * invMaxDistance);\n        vec4 transferSample = sampleVolumeColor(samplingPosition);\n        float alphaSample = transferSample.a * uAlphaCorrection;\n        if (seed.y < alphaSample * invSigmaMax) {\n            break;\n        }\n    } while (true);\n\n    return dist;\n}\n\nfloat sampleTransmittance(vec3 from, vec3 to, inout vec2 seed) {\n    float maxDistance = distance(from, to);\n    float dist = 0.0;\n    float invSigmaMax = 1.0 / uSigmaMax;\n    float invMaxDistance = 1.0 / maxDistance;\n    float transmittance = 1.0;\n\n    do {\n        seed = rand(seed);\n        dist -= log(1.0 - seed.x) * invSigmaMax;\n        if (dist > maxDistance) {\n            break;\n        }\n        vec3 samplingPosition = mix(from, to, dist * invMaxDistance);\n        vec4 transferSample = sampleVolumeColor(samplingPosition);\n        float alphaSample = transferSample.a * uAlphaCorrection;\n        transmittance *= 1.0 - alphaSample * invSigmaMax;\n    } while (true);\n\n    return transmittance;\n}\n\nvoid main() {\n    vec3 rayDirection = vRayTo - vRayFrom;\n    vec3 rayDirectionUnit = normalize(rayDirection);\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\n\n    if (tbounds.x >= tbounds.y) {\n        oColor = sampleEnvironmentMap(rayDirectionUnit);\n    } else {\n        vec3 from = mix(vRayFrom, vRayTo, tbounds.x);\n        vec3 to = mix(vRayFrom, vRayTo, tbounds.y);\n        float maxDistance = distance(from, to);\n\n        vec2 seed = vPosition + rand(vec2(uOffset, uOffset));\n        float dist = sampleDistance(from, to, seed);\n\n        if (dist > maxDistance) {\n            oColor = sampleEnvironmentMap(rayDirectionUnit);\n        } else {\n            from = mix(from, to, dist / maxDistance);\n            tbounds = max(intersectCube(from, uScatteringDirection), 0.0);\n            to = from + uScatteringDirection * tbounds.y;\n            vec4 diffuseColor = sampleVolumeColor(from);\n            vec4 lightColor = sampleEnvironmentMap(uScatteringDirection);\n            float transmittance = sampleTransmittance(from, to, seed);\n\n            oColor = diffuseColor * lightColor * transmittance;\n        }\n    }\n}\n"},"integrate":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\nuniform mediump sampler2D uFrame;\nuniform float uInvFrameNumber;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    vec4 acc = texture(uAccumulator, vPosition);\n    vec4 frame = texture(uFrame, vPosition);\n    oColor = acc + (frame - acc) * uInvFrameNumber;\n}\n"},"render":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = (aPosition + 1.0) * 0.5;\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    vec4 acc = texture(uAccumulator, vPosition);\n    oColor = acc;\n}\n"},"reset":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nout vec4 oColor;\n\nvoid main() {\n    oColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n"}},"MIP":{"generate":{"vertex":"#version 300 es\n\nuniform mat4 uMvpInverseMatrix;\n\nlayout(location = 0) in vec2 aPosition;\nout vec3 vRayFrom;\nout vec3 vRayTo;\n\n// #link /glsl/mixins/unproject\n@unproject\n\nvoid main() {\n    unproject(aPosition, uMvpInverseMatrix, vRayFrom, vRayTo);\n    gl_Position = vec4(aPosition, 0, 1);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler3D uVolume;\nuniform float uStepSize;\nuniform float uOffset;\n\nin vec3 vRayFrom;\nin vec3 vRayTo;\nout float oColor;\n\n// #link /glsl/mixins/intersectCube\n@intersectCube\n\nvoid main() {\n    vec3 rayDirection = vRayTo - vRayFrom;\n    vec2 tbounds = max(intersectCube(vRayFrom, rayDirection), 0.0);\n    if (tbounds.x >= tbounds.y) {\n        oColor = 0.0;\n    } else {\n        vec3 from = mix(vRayFrom, vRayTo, tbounds.x);\n        vec3 to = mix(vRayFrom, vRayTo, tbounds.y);\n\n        float t = 0.0;\n        float val = 0.0;\n        float offset = uOffset;\n        vec3 pos;\n        do {\n            pos = mix(from, to, offset);\n            val = max(texture(uVolume, pos).r, val);\n            t += uStepSize;\n            offset = mod(offset + uStepSize, 1.0);\n        } while (t < 1.0);\n        oColor = val;\n    }\n}\n"},"integrate":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = aPosition * 0.5 + 0.5;\n    gl_Position = vec4(aPosition, 0, 1);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\nuniform mediump sampler2D uFrame;\n\nin vec2 vPosition;\nout float oColor;\n\nvoid main() {\n    float acc = texture(uAccumulator, vPosition).r;\n    float frame = texture(uFrame, vPosition).r;\n    oColor = max(acc, frame);\n}\n"},"render":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    vPosition = aPosition * 0.5 + 0.5;\n    gl_Position = vec4(aPosition, 0, 1);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uAccumulator;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    float acc = texture(uAccumulator, vPosition).r;\n    oColor = vec4(acc, acc, acc, 1);\n}\n"},"reset":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nout float oColor;\n\nvoid main() {\n    oColor = 0.0;\n}\n"}}},"test":{"vertex":"#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec2 aPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nout vec4 color;\n\nvoid main() {\n    color = vec4(1.0, 0.5, 0.2, 1.0);\n}\n"},"tonemappers":{"AcesToneMapper":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n    vPosition = aPosition * 0.5 + 0.5;\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\nuniform float uExposure;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvec3 aces(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nfloat aces(float x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid main() {\n    vec4 src = texture(uTexture, vPosition);\n    oColor = vec4(aces(src.rgb * uExposure), 1);\n}\n"},"ArtisticToneMapper":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n    vPosition = aPosition * 0.5 + 0.5;\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\n#define M_PI 3.1415926535897932384626\n\nuniform mediump sampler2D uTexture;\nuniform float uLow;\nuniform float uMid;\nuniform float uHigh;\nuniform float uSaturation;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    vec4 color = texture(uTexture, vPosition);\n    color = (color - uLow) / (uHigh - uLow);\n    const vec3 gray = normalize(vec3(1));\n    color = vec4(mix(dot(color.rgb, gray) * gray, color.rgb, uSaturation), 1.0);\n    float midpoint = (uMid - uLow) / (uHigh - uLow);\n    float exponent = -log(2.0) / log(midpoint);\n    color = pow(color, vec4(exponent));\n    oColor = vec4(color.rgb, 1.0);\n}\n"},"FilmicToneMapper":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n    vPosition = aPosition * 0.5 + 0.5;\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\nuniform float uExposure;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvec3 filmic(vec3 x) {\n    vec3 X = max(vec3(0.0), x - 0.004);\n    vec3 result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\n    return pow(result, vec3(2.2));\n}\n\nfloat filmic(float x) {\n    float X = max(0.0, x - 0.004);\n    float result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\n    return pow(result, 2.2);\n}\n\nvoid main() {\n    vec4 src = texture(uTexture, vPosition);\n    oColor = vec4(filmic(src.rgb * uExposure), 1);\n}\n"},"LottesToneMapper":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n    vPosition = aPosition * 0.5 + 0.5;\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\nuniform float uExposure;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvec3 lottes(vec3 x) {\n    const vec3 a = vec3(1.6);\n    const vec3 d = vec3(0.977);\n    const vec3 hdrMax = vec3(8.0);\n    const vec3 midIn = vec3(0.18);\n    const vec3 midOut = vec3(0.267);\n\n    const vec3 b =\n        (-pow(midIn, a) + pow(hdrMax, a) * midOut) /\n        ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);\n    const vec3 c =\n        (pow(hdrMax, a * d) * pow(midIn, a) - pow(hdrMax, a) * pow(midIn, a * d) * midOut) /\n        ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);\n\n    return pow(x, a) / (pow(x, a * d) * b + c);\n}\n\nfloat lottes(float x) {\n    const float a = 1.6;\n    const float d = 0.977;\n    const float hdrMax = 8.0;\n    const float midIn = 0.18;\n    const float midOut = 0.267;\n\n    const float b =\n        (-pow(midIn, a) + pow(hdrMax, a) * midOut) /\n        ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);\n    const float c =\n        (pow(hdrMax, a * d) * pow(midIn, a) - pow(hdrMax, a) * pow(midIn, a * d) * midOut) /\n        ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);\n\n    return pow(x, a) / (pow(x, a * d) * b + c);\n}\n\nvoid main() {\n    vec4 src = texture(uTexture, vPosition);\n    oColor = vec4(lottes(src.rgb * uExposure), 1);\n}\n"},"RangeToneMapper":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n    vPosition = aPosition * 0.5 + 0.5;\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\nuniform float uMin;\nuniform float uMax;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvoid main() {\n    vec4 src = texture(uTexture, vPosition);\n    oColor = (src - uMin) / (uMax - uMin);\n}\n"},"Reinhard2ToneMapper":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n    vPosition = aPosition * 0.5 + 0.5;\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\nuniform float uExposure;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvec3 reinhard2(vec3 x) {\n    const float L_white = 4.0;\n    return (x * (1.0 + x / (L_white * L_white))) / (1.0 + x);\n}\n\nfloat reinhard2(float x) {\n    const float L_white = 4.0;\n    return (x * (1.0 + x / (L_white * L_white))) / (1.0 + x);\n}\n\nvoid main() {\n    vec4 src = texture(uTexture, vPosition);\n    oColor = vec4(reinhard2(src.rgb * uExposure), 1);\n}\n"},"ReinhardToneMapper":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n    vPosition = aPosition * 0.5 + 0.5;\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\nuniform float uExposure;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvec3 reinhard(vec3 x) {\n    return x / (1.0 + x);\n}\n\nfloat reinhard(float x) {\n    return x / (1.0 + x);\n}\n\nvoid main() {\n    vec4 src = texture(uTexture, vPosition);\n    oColor = vec4(reinhard(src.rgb * uExposure), 1);\n}\n"},"UchimuraToneMapper":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n    vPosition = aPosition * 0.5 + 0.5;\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\nuniform float uExposure;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvec3 uchimura(vec3 x, float P, float a, float m, float l, float c, float b) {\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = vec3(1.0 - smoothstep(0.0, m, x));\n    vec3 w2 = vec3(step(m + l0, x));\n    vec3 w1 = vec3(1.0 - w0 - w2);\n\n    vec3 T = vec3(m * pow(x / m, vec3(c)) + b);\n    vec3 S = vec3(P - (P - S1) * exp(CP * (x - S0)));\n    vec3 L = vec3(m + a * (x - m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nvec3 uchimura(vec3 x) {\n    const float P = 1.0;  // max display brightness\n    const float a = 1.0;  // contrast\n    const float m = 0.22; // linear section start\n    const float l = 0.4;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n\n    return uchimura(x, P, a, m, l, c, b);\n}\n\nfloat uchimura(float x, float P, float a, float m, float l, float c, float b) {\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    float w0 = 1.0 - smoothstep(0.0, m, x);\n    float w2 = step(m + l0, x);\n    float w1 = 1.0 - w0 - w2;\n\n    float T = m * pow(x / m, c) + b;\n    float S = P - (P - S1) * exp(CP * (x - S0));\n    float L = m + a * (x - m);\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nfloat uchimura(float x) {\n    const float P = 1.0;  // max display brightness\n    const float a = 1.0;  // contrast\n    const float m = 0.22; // linear section start\n    const float l = 0.4;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n\n    return uchimura(x, P, a, m, l, c, b);\n}\n\nvoid main() {\n    vec4 src = texture(uTexture, vPosition);\n    oColor = vec4(uchimura(src.rgb * uExposure), 1);\n}\n"},"Uncharted2ToneMapper":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n    vPosition = aPosition * 0.5 + 0.5;\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\nuniform float uExposure;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvec3 uncharted2Tonemap(vec3 x) {\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n    float W = 11.2;\n    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\nvec3 uncharted2(vec3 color) {\n    const float W = 11.2;\n    float exposureBias = 2.0;\n    vec3 curr = uncharted2Tonemap(exposureBias * color);\n    vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W));\n    return curr * whiteScale;\n}\n\nfloat uncharted2Tonemap(float x) {\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n    float W = 11.2;\n    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\nfloat uncharted2(float color) {\n    const float W = 11.2;\n    const float exposureBias = 2.0;\n    float curr = uncharted2Tonemap(exposureBias * color);\n    float whiteScale = 1.0 / uncharted2Tonemap(W);\n    return curr * whiteScale;\n}\n\nvoid main() {\n    vec4 src = texture(uTexture, vPosition);\n    oColor = vec4(uncharted2(src.rgb * uExposure), 1);\n}\n"},"UnrealToneMapper":{"vertex":"#version 300 es\n\nlayout(location = 0) in vec2 aPosition;\nout vec2 vPosition;\n\nvoid main() {\n    gl_Position = vec4(aPosition, 0, 1);\n    vPosition = aPosition * 0.5 + 0.5;\n}\n","fragment":"#version 300 es\nprecision mediump float;\n\nuniform mediump sampler2D uTexture;\nuniform float uExposure;\n\nin vec2 vPosition;\nout vec4 oColor;\n\nvec3 unreal(vec3 x) {\n    return x / (x + 0.155) * 1.019;\n}\n\nfloat unreal(float x) {\n    return x / (x + 0.155) * 1.019;\n}\n\nvoid main() {\n    vec4 src = texture(uTexture, vPosition);\n    oColor = vec4(unreal(src.rgb * uExposure), 1);\n}\n"}}}